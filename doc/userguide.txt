DiffKit User Guide
==================
@AUTHOR@
v@VERSION@, @BUILDDATE@ (SVN @REVISION@)


Prerequisites 
-------------
Ensure that you have first read the link:README.html[README file].

Introduction
------------

What DiffKit is
~~~~~~~~~~~~~~~
DiffKit is an application for comparing two tables of data, field-by-field.
DiffKit is able to report the differences (__Diff__s) at both the row and field
level, and allows the user to configure how to carry out the comparison (what to
compare, what to ignore). DiffKit is highly configurable with respect to the
sources of tabular data, the details of the comparison, and the characteristics
of the diff report (output). For instance, DiffKit is able to diff CSV files,
RDBMS tables, or custom data sources, in any combination. DiffKit is able to
compare fields within a prescribed tolerance (e.g. numeric field values will be
flagged as different only if the difference exceeds some threshold), is able to
diff text fields ignoring incidental formatting differences, and is able to
output the diffs as a structured text report or as SQL insert statements. This
is just a small sampling of the capabilities of DiffKit.


DiffKit is also a framework. It is Free Open Source Software (FOSS). DiffKit is
written in the Java programming language and is dependent on only the Java
Runtime Environment (JRE) and a handful of third party FOSS libraries that are
packaged as part of the DiffKit distribution. As an Open Source framework with
few dependencies, DiffKit can be easily and cleanly embedded in almost any Java
application, or any application that can bind Java packages.

DiffKit was designed to be easily extensible. That means it requires only a very
modest java programming effort to create custom row data providers (__Source__s),
custom field comparators (__Diffor__s), and custom output formatters (__Sink__s).

DiffKit is a command-line application that is configured entirely by XML files.
Because there is no GUI, and because it's file driven, and because it runs on
Java, DiffKit is able to execute in a huge range of computing environments--
Windows and Mac desktops, or Linux and Solaris servers. These characteristics
also make DiffKit ideal for scripting or embedding into process chains. Also,
DiffKit was designed with high-volume applications in mind. It uses a
row-streaming mechanism to maintain a very low memory overhead during diff
execution, so DiffKit is able to quickly and efficiently diff tables that have
tens of millions of rows.


What DiffKit is not 
~~~~~~~~~~~~~~~~~~~

DiffKit is not a visual comparison tool; it does not have a GUI. DiffKit is not
a code or unstructured text comparison tool-- it is designed to compare tables
(data that is arranged in rows and columns). If you want to compare unstructured
text, you should use Unix diffutils
footnote:[http://www.gnu.org/software/diffutils/.]. DiffKit is not a
synchronization tool. DiffKit has no capabilities to patch one side to make it
look like the other side; i.e. it can only report differences, not act on them.
DiffKit is not an RDBMS schema synchronization tool. There are many products on
the market that already do this. While you *can* use DiffKit to diff RDBMS
schemas, you will have to supply the configuration files yourself-- out of the
box DiffKit does not know how to identify the schema or catalog tables for any
particular vendor product. Finally, DiffKit is not very helpful for diff'ng
binary files. The diff reporting mechanism is oriented towards data types that
can be displayed as text.

Why use DiffKit?
~~~~~~~~~~~~~~~~

There are many uses for DiffKit, a couple of which are explored in detail in
<<Motivations-and-Uses,Motivations and Uses>>. Briefly, DiffKit is an excellent
application for enterprise data regression. It's quite common that enterprise
systems have complex workflows that produce large or complex RDBMS data output.
By diff'ng newly produced table values against expected table values, you can
ensure that you do not experience unanticipated changes to output as a result of
changes to the process. Likewise, most enterprise development environments rely
on different databases for different stages in the SDLC. It can become difficult
to keep the database objects in synch across these different environments.
DiffKit can diff the schemas to report on differences amongst the same database
objects across different environments.

There are many reasons to use DiffKit rather than other products. DiffKit is
free and open source. Also, as far as I know, there are no products on the
market, commercial or free, that are designed for high-performance, high-volume,
enterprise data diff'ng. Also, DiffKit is command-line driven, so it is
conveniently scriptable and embeddable into workflows. DiffKit has a clean,
simple, Object Oriented Design that makes it easy for Java programmers to
extend. Finally, DiffKit is a high quality product, undergoing continuous
testing to ensure the accuracy of its results.

Quality control
~~~~~~~~~~~~~~~~
The integrity of DiffKit is maintained via two levels of testing: unit testing,
and high level functional regression testing. The DiffKit project contains
roughly 90 low-level unit tests. These tests are executed before each release.
But more importantly, the DiffKit standalone application carries with it a
complete, high-level functional regression suite. Not only is this test suite
exercised before every release but, because it is embedded in the standalone
application, end-users are able to execute this test suite at any time.

The test suite comprises __TestCase__s. Each TestCase tests a particular scenario
which is specified in a configuration file. The TestCase includes inputs, both
left hand side (LHS) and right hand side (RHS), comparison configuration, and
expected output. The _TestCaseRunner_ will diff the LHS vs. the RHS and compare
the actual results with the expected (known good) results. If the actual results
do not match the expected results, the TestCase fails. DiffKit embeds a fully
functional H2 database in order to carry out RDBMS based comparison. Each
TestCase is fully documented. If you run the tests from the standalone
application, you can inspect the resulting "tcr" directory and there you will
find the input files, expected diff files and documentation (README) for each
TestCase.


Tutorial
--------

Tutorial 1 -- Diff'ng file tables
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
In this tutorial we will diff two CSV files. Like most diff utilities, DiffKit
arbitrarily names one of the tables (files) the Left Hand Side (_LHS_) and the
other table (file) the Right Hand Side (_RHS_). In order to carry out a diff,
DiffKit must be configured with the location of the LHS and RHS tables, the
characteristics of the comparison, and a description of the desired output. All
of this information is specified in a _Plan_ file. A Plan file is an XML
configuration file (for enterprise Java programmers, it's a Spring bean
configuration file). There are two kinds of plans: _MagicPlan_ and
_PassthroughPlan_. In this example we will use a _MagicPlan_.

This plan is called _Magic_ because it infers a lot of information, rather than
requiring the user to fully specify every last detail of how the comparison
should be carried out. The goal of the magic plan is to allow the user to
specify the bare minimum amount of information required to accurately perform
the diff.

In this example, that bare minimum of information is: the LHS file name, the RHS
file name, and the name of a file to send the output to. Information that is
*not* specified here, which the MagicPlan will infer, includes: which columns
should be diff'd, what _key_ should be used to match each row from the LHS to a
row on the RHS, how to map columns on the left to columns on the right, and what
type of comparison (which _Diffor_) to apply at each LHS-column-to-RHS-column
mapping. In the case of the MagicPlan, the convenient default specifications
that the MagicPlan provides are: all columns that appear on both the LHS and RHS
will be diffed, other columns are ignored; the first column on each side is
designated the _key_ (analogous to a SQL key), used to join the rows; each
column on the LHS will be mapped to the column on the RHS having the same name;
an exact textual comparison will be performed (_DKEqualsDiffor_ will be
applied).

After you have unzipped the DiffKit distribution (diffkit-<version>.zip), you
should see these files and directories:
-----------------
conf/
diffkit-app.jar
doc/
eg/
-----------------
diffkit-app.jar is the standalone java application. It is completely
self-contained, and can be run this way:
-----------------
java -jar diffkit-app.jar
-----------------

All of the data and configuration files needed for this tutorial are in the eg/
directory:
-----------------
cd eg/
-----------------
All of the files in this directory come from the DiffKit builtin
<<Test-Cases,Test Case suite>>. In this tutorial, we will start by invoking the same
diff that TestCase9 invokes. It utilizes these files:
-----------------
test9.lhs.csv
test9.rhs.csv
test9.plan.xml
-----------------
We want DiffKit to compare the data table in test9.lhs.csv with that in
test9.rhs.csv. The plan for this is almost as simple as a plan can get:

.test9.plan.xml
-----------------
<beans ...>
	<bean id="plan" class="org.diffkit.diff.conf.DKMagicPlan">
		<property name="lhsFilePath" value="./test9.lhs.csv" />
		<property name="rhsFilePath" value="./test9.rhs.csv" />
		<property name="sinkFilePath" value="./test9.sink.diff" />
	</bean>
</beans>
-----------------
This file shows that we are using a _MagicPlan_ (instead of a
_PassthroughPlan_) and where to find the LHS and RHS csv files. It also
specifies where the _Sink_ should write its output file. A _Sink_ is where diffs
are sent to for formatting. We can run the diff this way:
-----------------
java -jar ../diffkit-app.jar -planfiles test9.plan.xml
-----------------
DiffKit prints a summary of the results to the console:
-----------------
diff'd 8 rows in 0:00:00.009, found:
!4 row diffs
@2 column diffs
-----------------
The summary tells us that there were 4 row diffs; a row diff occurs when DiffKit
finds a row on one side, but no corresponding row on the other side. Rows are
uniquely identified by a _key_ (analogous to a primary key in relational DBs)
which defaults to column1 if not otherwise specified. The summary states that
there were also 2 column diffs, which means that DiffKit was able to join (align)
the rows, but that values in some of the columns were different between the left
and right hand side.

Running test9.plan.xml above created an output (diff) file named test9.sink.diff.
That file contains an entry for each diff discovered. The first entry in that file 
describes a column diff:

.test9.sink.diff
-----------------
@{column1=1111}
column2
<1111
>xxxx
-----------------
It tells us that the row identified by the key value (column1=1111) has a column
diff in column2. The lhs value for column2 is 1111 while the rhs value is xxxx.
The next entry in the diff file describes a row diff:

.test9.sink.diff cont.
-----------------
!{column1=2222}
<
-----------------
This indicates that the row identified by column1=2222 is missing from the lhs.
Or put another way, this row is present on the rhs and not present on the lhs. 
You should open test9.lhs.csv side-by-side with test9.rhs.csv in order to verify
that all entries in the diff file match your expectations.

test11.plan.xml shows how to explicitly specify which columns constitute the _key_,
used to align (join) the rows between lhs and rhs:

.test11.plan.xml
-----------------
   ...
   <property name="keyColumnNames">
      <list>
         <value>column3</value>
   ...
-----------------


test13.plan.xml demonstrates how to instruct DiffKit to consider only certain
columns during comparison, ignoring all other columns:

.test13.plan.xml
-----------------
   ...
   <property name="diffColumnNames">
      <list>
         <value>column2</value>
   ...
-----------------
It also shows how to specify that rows should be identified in the output (diff)
file by values other than the key values:

.test13.plan.xml cont.
-----------------
   ...
   <property name="displayColumnNames">
      <list>
         <value>column1</value>
         <value>column3</value>
   ...
-----------------

test14.plan.xml demonstrates how to tell DiffKit to consider all
columns during comparison except for a specified list (blacklist).

.test14.plan.xml
-----------------
   ...
   <property name="ignoreColumnNames">
      <list>
         <value>column3</value>
         <value>column4</value>
   ...
-----------------

test21.plan.xml shows how to specify which _kinds_ of diffs should be considered: 
ROW_DIFF, COLUMN_DIFF, or BOTH (default). It also shows how to tell DiffKit to 
halt diffing after a certain number of diffs has been recorded:

.test21.plan.xml
-----------------
   ...
   <property name="diffKind" value="ROW_DIFF" />
   <property name="maxDiffs" value="2" />
   ...
-----------------



Tutorial 2 -- Diff'ng database tables
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
NOTE: You should complete Tutorial 1 before starting on this tutorial. Tutorial
1 introduces terminology that is used here.

In this tutorial we will diff two RDBMS database tables. Diff'ng DB tables uses
plan files in the same fashion as diff'ng files. The only difference is that
instead of file paths, you must provide table names, and you must also tell
DiffKit how to connect to the LHS and RHS databases.

The DiffKit standalone application (diffkit-app.jar) carries with it a fully
functional embedded SQL database: H2 footnote:[http://www.h2database.com/.]. The
storage for the tutorial H2 database is in a single file: eg/demo.h2.db.
Appropriate database tables have been created in demo.h2.db and prepopulated
with all of the data in files test10.lhs.csv and test10.rhs.csv. The CSV files
are here simply as a convenience, to allow you to see the test data without
having to open a database browser. If you would like to view the H2 tables and
data, you need a DB browser that can use a type 4 JDBC driver to connect to
a database. DiffKit can run the embedded H2 DB as a tcp server 
from the eg/
directory, allowing you to connect from an external DB browser:
-----------------
java -jar ../diffkit-app.jar -demoDB
-----------------
Then configure a connection to this demo database within your favorite JDBC
enabled database browser:
-----------------
driver name: H2 JDBC Driver
driver class name: org.h2.Driver
driver jar: h2-1.2.135.jar (you can unzip diffkit-app.jar to get a copy)
connection URL: jdbc:h2:<absolute path of eg/ directory>/demo
database name: demo
username: test
password: test
-----------------
Your DB browser will show you the tables TEST10_LHS_TABLE and TEST10_RHS_TABLE 
(amongst others) populated with the data values from the corresponding CSV files.

test10.plan.xml demonstrates how to specify the table names used in the
comparison:

.test10.plan.xml
-----------------
   ...
   <property name="lhsDBTableName" value="TEST10_LHS_TABLE" />
   <property name="rhsDBTableName" value="TEST10_RHS_TABLE" />
   <property name="dbConnectionInfo" ref="connectionInfo" />
   ...
-----------------
In this case, both tables reside in the same database, referenced by
"connectionInfo". Of course we also have to provide values for connectionInfo.
We could put the connectionInfo element for these tables in the test10.plan.xml
file, and then all information needed for the diff would be in one config file.
Instead, we isolate the database connectionInfo values into a separate file:

.dbConnectionInfo.xml
-----------------
   ...
   <bean id="connectionInfo" class="org.diffkit.db.DKDBConnectionInfo">
     <constructor-arg index="0" value="test" />
     <constructor-arg index="1" value="H2" />
     <constructor-arg index="2" value="file:./demo" />
     <constructor-arg index="3">
			<null />
     </constructor-arg>
     <constructor-arg index="4">
			<null />
     </constructor-arg>
     <constructor-arg index="5" value="test" />
     <constructor-arg index="6" value="test" />
  </bean>
-----------------
This allows us to reuse the connectionInfo in other plans as well. The
connectionInfo points to an embedded H2 database named "test", which is stored
in a file at "./demo" (i.e. eg/demo.h2.db). The username is "test" and the
password is "test". An embedded H2 database will run in the same process as
DiffKit itself-- you do not need to run the diffkit-app.jar demoDB. To run the
test10 plan:
-----------------
java -jar ../diffkit-app.jar -planfiles test10.plan.xml,dbConnectionInfo.xml
-----------------
Test10 shows that DiffKit allows the user to specify what _key_ should be used
to join (align) the rows, even if a different SQL primary key (PK) is already 
defined within the database:

.test10.plan.xml cont.
-----------------
   ...
   <property name="keyColumnNames">
      <list>
         <value>COLUMN3</value>
   ...
-----------------

In this particular case, the PK defined in the database for both tables is
column1. If DiffKit had used column1 as its _key_, then all rows would have
appeared as row diffs, because no rows join. Instead, we specified that the
_key_ is column3, in which case all rows join and there are no row diffs.

DiffKit can compare tables across different physical and/or logical databases.
test18.plan.xml demonstrates this:

.test18.plan.xml
-----------------
   ...
   <bean id="connectionInfo" class="org.diffkit.diff.conf.DKMagicPlan">
     ...
     <property name="lhsDBConnectionInfo" ref="lhsDBConnectionInfo" />
     <property name="rhsDBConnectionInfo" ref="rhsDBConnectionInfo" />
     ...
   </bean>
   <bean id="lhsDBConnectionInfo" class="org.diffkit.db.DKDBConnectionInfo">
     ...
     <constructor-arg index="2" value="mem:testcase18_lhs;DB_CLOSE_DELAY=-1" />
     ...
   </bean>
   <bean id="rhsDBConnectionInfo" class="org.diffkit.db.DKDBConnectionInfo">
     ...
     <constructor-arg index="2" value="mem:testcase18_rhs;DB_CLOSE_DELAY=-1" />
     ...
  </bean>
-----------------
In this case, table "LHS_TABLE" is located in a database named "testcase18_lhs",
while table "RHS_TABLE" is located in a database named "testcase18_rhs".


Tutorial 3 -- PassthroughPlan
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
NOTE: You should complete Tutorial 2 before starting this tutorial. Tutorial
2 introduces terminology that is used here.


[[Motivations-and-Uses]]
Motivations and Uses
--------------------

Regression testing
~~~~~~~~~~~~~~~~~~

DB schema comparison
~~~~~~~~~~~~~~~~~~~~



Concepts
--------

Real world entities
~~~~~~~~~~~~~~~~~~

Modelling entities
~~~~~~~~~~~~~~~~~~

TableModel
^^^^^^^^^^

ColumnModel
^^^^^^^^^^^

Source
~~~~~~

Row Alignment
~~~~~~~~~~~~~

Sink
~~~~

Plan
~~~~

Map
^^^

Diffor
^^^^^^

MagicPlan
^^^^^^^^^

PassthroughPlan
^^^^^^^^^^^^^^

Diff
~~~~

ROW_DIFF
^^^^^^^^^

COLUMN_DIFF
^^^^^^^^^^^

Summary information
^^^^^^^^^^^^^^^^^^^

Extending Diffkit
-----------------

Custom Source -- ArchiveSource
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Coming soon.


Custom Diffor -- ?
~~~~~~~~~~~~~~~~~~~~
Coming soon.


Custom Sink -- XMLSink
~~~~~~~~~~~~~~~~~~~~~~
Coming soon.


Putting it together
~~~~~~~~~~~~~~~~~~~
Coming soon.

[[Test-Cases]]
Test Cases
----------


[appendix]
Example Appendix
----------------
AsciiDoc article appendices are just just article sections with
'specialsection' titles.

Appendix Sub-section
~~~~~~~~~~~~~~~~~~~~
Appendix sub-section at level 2.

[glossary]
Example Glossary
----------------
Glossaries are optional. Glossaries entries are an example of a style
of AsciiDoc labeled lists.

[glossary]
A glossary term::
  The corresponding (indented) definition.

A second glossary term::
  The corresponding (indented) definition.


ifdef::backend-docbook[]
[index]
Example Index
-------------
////////////////////////////////////////////////////////////////
The index is normally left completely empty, it's contents being
generated automatically by the DocBook toolchain.
////////////////////////////////////////////////////////////////
endif::backend-docbook[]

