DiffKit User Guide
==================
@AUTHOR@
v@VERSION@, @BUILDDATE@ (SVN @REVISION@)


Prerequisites 
-------------
Ensure that you have first read the link:README.html[README file].

Introduction
------------

What DiffKit is
~~~~~~~~~~~~~~~
DiffKit is an application for comparing two tables of data, field-by-field.
DiffKit is able to report the differences (__Diff__s) at both the row and field
level, and allows the user to configure how to carry out the comparison (what to
compare, what to ignore). DiffKit is highly configurable with respect to the
sources of tabular data, the details of the comparison, and the characteristics
of the diff report (output). For instance, DiffKit is able to diff CSV files,
RDBMS tables, or custom data sources, in any combination. DiffKit is able to
compare fields within a prescribed tolerance (e.g. numeric field values will be
flagged as different only if the difference exceeds some threshold), is able to
diff text fields ignoring incidental formatting differences, and is able to
output the diffs as a structured text report or as SQL insert statements. This
is just a small sampling of the capabilities of DiffKit.


DiffKit is also a framework. It is Free Open Source Software (FOSS). DiffKit is
written in the Java programming language and is dependent on only the Java
Runtime Environment (JRE) and a handful of third party FOSS libraries that are
packaged as part of the DiffKit distribution. As an Open Source framework with
few dependencies, DiffKit can be easily and cleanly embedded in almost any Java
application, or any application that can bind Java packages.

DiffKit was designed to be easily extensible. That means it requires only a very
modest java programming effort to create custom row data providers (__Source__s),
custom field comparators (__Diffor__s), and custom output formatters (__Sink__s).

DiffKit is a command-line application that is configured entirely by XML files.
Because there is no GUI, and because it's file driven, and because it runs on
Java, DiffKit is able to execute in a huge range of computing environments--
Windows and Mac desktops, or Linux and Solaris servers. These characteristics
also make DiffKit ideal for scripting or embedding into process chains. Also,
DiffKit was designed with high-volume applications in mind. It uses a
row-streaming mechanism to maintain a very low memory overhead during diff
execution, so DiffKit is able to quickly and efficiently diff tables that have
tens of millions of rows.


What DiffKit is not 
~~~~~~~~~~~~~~~~~~~

DiffKit is not a visual comparison tool; it does not have a GUI. DiffKit is not
a code or unstructured text comparison tool-- it is designed to compare tables
(data that is arranged in rows and columns). If you want to compare unstructured
text, you should use Unix diffutils
footnote:[http://www.gnu.org/software/diffutils/.]. DiffKit is not a
synchronization tool. DiffKit has no capabilities to patch one side to make it
look like the other side; i.e. it can only report differences, not act on them.
DiffKit is not an RDBMS schema synchronization tool. There are many products on
the market that already do this. While you *can* use DiffKit to diff RDBMS
schemas, you will have to supply the configuration files yourself-- out of the
box DiffKit does not know how to identify the schema or catalog tables for any
particular vendor product. Finally, DiffKit is not very helpful for diff'ng
binary files. The diff reporting mechanism is oriented towards data types that
can be displayed as text.

Why use DiffKit?
~~~~~~~~~~~~~~~~

There are many uses for DiffKit, a couple of which are explored in detail in
<<Motivations-and-Uses,Motivations and Uses>>. Briefly, DiffKit is an excellent
application for enterprise data regression. It's quite common that enterprise
systems have complex workflows that produce large or complex RDBMS data output.
By diff'ng newly produced table values against expected table values, you can
ensure that you do not experience unanticipated changes to output as a result of
changes to the process. Likewise, most enterprise development environments rely
on different databases for different stages in the SDLC. It can become difficult
to keep the database objects in synch across these different environments.
DiffKit can diff the schemas to report on differences amongst the same database
objects across different environments.

There are many reasons to use DiffKit rather than other products. DiffKit is
free and open source. Also, as far as I know, there are no products on the
market, commercial or free, that are designed for high-performance, high-volume,
enterprise data diff'ng. Also, DiffKit is command-line driven, so it is
conveniently scriptable and embeddable into workflows. DiffKit has a clean,
simple, Object Oriented Design that makes it easy for Java programmers to
extend. Finally, DiffKit is a high quality product, undergoing continuous
testing to ensure the accuracy of its results.

Quality control
~~~~~~~~~~~~~~~~
The integrity of DiffKit is maintained via two levels of testing: unit testing,
and high level functional regression testing. The DiffKit project contains
roughly 90 low-level unit tests. These tests are executed before each release.
But more importantly, the DiffKit standalone application carries with it a
complete, high-level functional regression suite. Not only is this test suite
exercised before every release but, because it is embedded in the standalone
application, end-users are able to execute this test suite at any time.

The test suite comprises __TestCase__s. Each TestCase tests a particular scenario
which is specified in a configuration file. The TestCase includes inputs, both
left hand side (LHS) and right hand side (RHS), comparison configuration, and
expected output. The _TestCaseRunner_ will diff the LHS vs. the RHS and compare
the actual results with the expected (known good) results. If the actual results
do not match the expected results, the TestCase fails. DiffKit embeds a fully
functional H2 database in order to carry out RDBMS based comparison. Each
TestCase is fully documented. If you run the tests from the standalone
application, you can inspect the resulting "tcr" directory and there you will
find the input files, expected diff files and documentation (README) for each
TestCase.


Tutorial
--------

Tutorial 1 -- Diff'ng file tables
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
In this tutorial we will diff two CSV files. Like most diff utilities, DiffKit
arbitrarily names one of the tables (files) the Left Hand Side (_LHS_) and the
other table (file) the Right Hand Side (_RHS_). In order to carry out a diff,
DiffKit must be configured with the location of the LHS and RHS tables, the
characteristics of the comparison, and a description of the desired output. All
of this information is specified in a _Plan_ file. A Plan file is an XML
configuration file (for enterprise Java programmers, it's a Spring bean
configuration file). There are two kinds of plans: _MagicPlan_ and
_PassthroughPlan_. In this example we will use a _MagicPlan_.

This plan is called _Magic_ because it infers a lot of information, rather than
requiring the user to fully specify every last detail of how the comparison
should be carried out. The goal of the magic plan is to allow the user to
specify the bare minimum amount of information required to accurately perform
the diff.

In this example, that bare minimum of information is: the LHS file name, the RHS
file name, and the name of a file to send the output to. Information that is
*not* specified here, which the MagicPlan will infer, includes: which columns
should be diff'd, what _key_ should be used to match each row from the LHS to a
row on the RHS, how to map columns on the left to columns on the right, and what
type of comparison (which _Diffor_) to apply at each LHS-column-to-RHS-column
mapping. In the case of the MagicPlan, the convenient default specifications
that the MagicPlan provides are: all columns that appear on both the LHS and RHS
will be diffed, other columns are ignored; the first column on each side is
designated the _key_ (analogous to a SQL key), used to join the rows; each
column on the LHS will be mapped to the column on the RHS having the same name;
an exact textual comparison will be performed (_DKEqualsDiffor_ will be
applied).

After you have unzipped the DiffKit distribution (diffkit-<version>.zip), you
should see these files and directories:
-----------------
conf
diffkit-app.jar
doc
eg
-----------------
diffkit-app.jar is the standalone java application. It is completely
self-contained, and can be run this way:
-----------------
java -jar diffkit-app.jar
-----------------

All of the data and configuration files needed for this tutorial are in the eg/
directory:
-----------------
cd eg/
-----------------
All of the files in this directory come from the DiffKit builtin 
<<Test-Cases,Test Cases>>



Tutorial 2 -- Diff'ng database tables
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
NOTE: You should complete Tutorial 1 before embarking on this tutorial. Tutorial
1 introduces terminology that is used here.

In this tutorial we will diff two RDBMS database tables. 

Tutorial 3 -- PassthroughPlan
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
NOTE: You should complete Tutorial 2 before embarking on this tutorial. Tutorial
2 introduces terminology that is used here.


[[Motivations-and-Uses]]
Motivations and Uses
--------------------

Regression testing
~~~~~~~~~~~~~~~~~~

DB schema comparison
~~~~~~~~~~~~~~~~~~~~



Concepts
--------

Real world entities
~~~~~~~~~~~~~~~~~~

Modelling entities
~~~~~~~~~~~~~~~~~~

TableModel
^^^^^^^^^^

ColumnModel
^^^^^^^^^^^

Source
~~~~~~

Row Alignment
~~~~~~~~~~~~~

Sink
~~~~

Plan
~~~~

Map
^^^

Diffor
^^^^^^

MagicPlan
^^^^^^^^^

PassthroughPlan
^^^^^^^^^^^^^^

Diff
~~~~

ROW_DIFF
^^^^^^^^^

COLUMN_DIFF
^^^^^^^^^^^

Summary information
^^^^^^^^^^^^^^^^^^^

Extending Diffkit
-----------------

Custom Source -- ArchiveSource
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Coming soon.


Custom Diffor -- ?
~~~~~~~~~~~~~~~~~~~~
Coming soon.


Custom Sink -- XMLSink
~~~~~~~~~~~~~~~~~~~~~~
Coming soon.


Putting it together
~~~~~~~~~~~~~~~~~~~
Coming soon.

[[Test-Cases]]
Test Cases
----------


[appendix]
Example Appendix
----------------
AsciiDoc article appendices are just just article sections with
'specialsection' titles.

Appendix Sub-section
~~~~~~~~~~~~~~~~~~~~
Appendix sub-section at level 2.

[glossary]
Example Glossary
----------------
Glossaries are optional. Glossaries entries are an example of a style
of AsciiDoc labeled lists.

[glossary]
A glossary term::
  The corresponding (indented) definition.

A second glossary term::
  The corresponding (indented) definition.


ifdef::backend-docbook[]
[index]
Example Index
-------------
////////////////////////////////////////////////////////////////
The index is normally left completely empty, it's contents being
generated automatically by the DocBook toolchain.
////////////////////////////////////////////////////////////////
endif::backend-docbook[]

