DiffKit User Guide
==================
@AUTHOR@
v@VERSION@, @BUILDDATE@ (SVN @REVISION@)


Prerequisites 
-------------
Ensure that you have first read the link:README.html[README file].

Introduction
------------

What DiffKit is
~~~~~~~~~~~~~~~
DiffKit is an application for comparing two tables of data, field-by-field.
DiffKit is able to report the differences (_Diff_ s) at both the row and field
level, and allows the user to configure how to carry out the comparison (what to
compare, what to ignore). DiffKit is highly configurable with respect to the
sources of tabular data, the details of the comparison, and the characteristics
of the diff report (output). For instance, DiffKit is able to diff CSV files,
RDBMS tables, or custom data sources, in any combination. DiffKit is able to
compare fields within a prescribed tolerance (e.g. numeric field values will be
flagged as different only if the difference exceeds some threshold), is able to
diff text fields ignoring incidental formatting differences, and is able to
output the diffs as a structured text report or as SQL insert statements. This
is just a small sampling of the capabilities of DiffKit.


DiffKit is also a framework. It is Free Open Source Software (FOSS). DiffKit is
written in the Java programming language and is dependent on only the Java
Runtime Environment (JRE) and a handful of third party FOSS libraries that are
packaged as part of the DiffKit distribution. As an Open Source framework with
few dependencies, DiffKit can be easily and cleanly embedded in almost any Java
application, or any application that can bind Java packages.

DiffKit was designed to be easily extensible. That means it requires only a very
modest java programming effort to create custom row data providers (_Source_ s),
custom field comparators (_Diffor_ s), and custom output formatters (_Sink_ s).

DiffKit is a command-line application that is configured entirely by XML files.
Because there is no GUI, and because it's file driven, and because it runs on
Java, DiffKit is able to execute in a huge range of computing environments--
Windows and Mac desktops, or Linux and Solaris servers. These characteristics
also make DiffKit ideal for scripting or embedding into process chains. Also,
DiffKit was designed with high-volume applications in mind. It uses a
row-streaming mechanism to maintain a very low memory overhead during diff
execution, so DiffKit is able to quickly and efficiently diff tables that have
tens ofmillions of rows.


What DiffKit is not 
~~~~~~~~~~~~~~~~~~~

DiffKit is not a visual comparison tool; it does not have a GUI. DiffKit is not
a code or unstructured text comparison tool-- it is designed to compare tables
(data that is arranged in rows and columns). If you want to compare unstructured
text, you should use Unix diffutils
footnote:[http://www.gnu.org/software/diffutils/.]. DiffKit is not a
synchronization tool. DiffKit has no capabilities to patch one side to make it
look like the other side; i.e. it can only report differences, not act on them.
Finally, DiffKit is not an RDBMS schema synchronization tool. There are many
products on the market that already do this. While you *can* use DiffKit to diff
RDBMS schemas, you will have to supply the configuration files yourself-- out of
the box DiffKit does not know how to identify the schema or catalog tables for
any particular vendor product.


Why use DiffKit?
~~~~~~~~~~~~~~~~

There are many uses for DiffKit, a couple of which are explored in detail in
<<Motivations_and_Uses,Motivations and Uses>>. Briefly, DiffKit is an excellent
application for enterprise data regression. It's quite common that enterprise
systems have complex workflows that produce large or complex RDBMS data output.
By diff'ng newly produced table values against expected table values, you can
ensure that you do not experience unanticipated changes to output as a result of
changes to the process. Likewise, most enterprise development environments rely
on different databases for different stages in the SDLC. It can become difficult
to keep the database objects in synch across these different environments.
DiffKit can diff the schemas to report on differences amongst the same database
objects across different environments.

There are many reasons to use DiffKit rather than other products. DiffKit is
free and open source. Also, as far as I know, there are no products on the
market, commercial or free, that are designed for high-performance, high-volume,
enterprise data diff'ng. Also, DiffKit is command-line driven, so it is
conveniently scriptable and embeddable into workflows. DiffKit has a clean,
simple, Object Oriented design that makes it simple for Java programmers to
extend. Finally, DiffKit maintains high levels of quality through an extensive
regression TestCase suite.


Quality control
~~~~~~~~~~~~~~~~
DiffKit maintains integrity through two levels of testing: unit testing, and
high level functional regression testing. The DiffKit project contains roughly
90 low-level unit tests. These tests are executed before each release. But more
importantly, the DiffKit standalone application carries with it a complete,
high-level functional regression suite. Not only is this test suite exercised
before every release, but because it is embedded in the standalone application,
end-users are able to execute this test suite at any time.

The test suite comprises _TestCase_ s. Each TestCase tests a particular scenario
which is specified in a configuration file. The TestCase includes inputs, both
left hand side (LHS) and right hand side (RHS), comparison configuration, and
expected output. The _TestCaseRunner_ will diff the LHS vs. the RHS and compare
the actual results with the expected (known good) results. If the actual results
do not match the expected results, the TestCase fails. DiffKit embeds a fully
functional H2 database in order to carry out RDBMS based comparison. Each
TestCase is fully documented. If you run the tests from the standalone
application, you can inspect the resulting "tcr" directory and there you will
find the input files, expected diff files and documentation (README) for each
TestCase.


Tutorial
--------

Tutorial 1 -- Diff'ng file tables
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Tutorial 2 -- Diff'ng database tables
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Tutorial 3 -- PassthroughPlan
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


[[Motivations_and_Uses]]
Motivations and Uses
--------------------

Regression testing
~~~~~~~~~~~~~~~~~~

DB schema comparison
~~~~~~~~~~~~~~~~~~~~



Concepts
--------

Real world entities
~~~~~~~~~~~~~~~~~~

Modelling entities
~~~~~~~~~~~~~~~~~~

TableModel
^^^^^^^^^^

ColumnModel
^^^^^^^^^^^

Source
~~~~~~

Row Alignment
~~~~~~~~~~~~~

Sink
~~~~

Plan
~~~~

Map
^^^

Diffor
^^^^^^

MagicPlan
^^^^^^^^^

PassthroughPlan
^^^^^^^^^^^^^^

Diff
~~~~

ROW_DIFF
^^^^^^^^^

COLUMN_DIFF
^^^^^^^^^^^

Summary information
^^^^^^^^^^^^^^^^^^^

Extending Diffkit
-----------------

Custom Source -- ArchiveSource
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Coming soon.


Custom Diffor -- ?
~~~~~~~~~~~~~~~~~~~~
Coming soon.


Custom Sink -- XMLSink
~~~~~~~~~~~~~~~~~~~~~~
Coming soon.


Putting it together
~~~~~~~~~~~~~~~~~~~
Coming soon.


[appendix]
Example Appendix
----------------
AsciiDoc article appendices are just just article sections with
'specialsection' titles.

Appendix Sub-section
~~~~~~~~~~~~~~~~~~~~
Appendix sub-section at level 2.

[glossary]
Example Glossary
----------------
Glossaries are optional. Glossaries entries are an example of a style
of AsciiDoc labeled lists.

[glossary]
A glossary term::
  The corresponding (indented) definition.

A second glossary term::
  The corresponding (indented) definition.


ifdef::backend-docbook[]
[index]
Example Index
-------------
////////////////////////////////////////////////////////////////
The index is normally left completely empty, it's contents being
generated automatically by the DocBook toolchain.
////////////////////////////////////////////////////////////////
endif::backend-docbook[]

